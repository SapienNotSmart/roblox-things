
local library = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))() -- aonde a library vai ficar armazenada

local w1 = library:Window("a") -- Text

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Configurações gerais
local waitingPositions = {
    {position = Vector3.new(95, 38, -1327), waitTime = 15},
    {position = Vector3.new(71, 70, -1538), waitTime = 5}
}
local safeReturnPos = Vector3.new(112, 41, -1365)

-- Variáveis para controle do script
local running = false
local currentWaitingPositionIndex = 1
local inAnyMinigame = false
local state = "WAITING"  -- "WAITING", "JOINING", "IN_MINIGAME"

-- Configurações Sakura Swoop
local sakuraRunning = false
local sakuraPlatformParts = {}
local sakuraTotalModelsPulled = 0
local sakuraMaxModelsToCollect = 40
local sakuraCollectionComplete = false
local sakuraFirstPosition = Vector3.new(-2968, 5502, 11817)
local sakuraSecondPosition = Vector3.new(-3041, 5529, 11928)

-- Configurações Tear Up Toykyo
local tearUpRunning = false

-- Path dos timers
local sakuraTimerLabel = workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Billboard.BillboardGui.TimerLabel
local tearUpTimerLabel = workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Billboard.BillboardGui.TimerLabel

-- Path das join zones
local function getSakuraJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("BlossomShakedownJoinZone") 
    and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Collider
    end
    return nil
end

local function getTearUpJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("TearUpToykyoJoinZone") 
    and Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Collider
    end
    return nil
end

-- Funções utilitárias
local function teleportPlayer(pos)
    if typeof(pos) ~= "Vector3" then return false end
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            char.HumanoidRootPart.CFrame = CFrame.new(pos)
            for i = 1, 3 do
                task.wait(0.1)
                char.HumanoidRootPart.CFrame = CFrame.new(pos)
            end
        end)
        return true
    end
    return false
end

local function simulateJump()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        pcall(function()
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end)
        return true
    end
    return false
end

local function freezePlayer(position)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    if not hrp:FindFirstChild("FreezePosition") then
        pcall(function()
            local bp = Instance.new("BodyPosition")
            bp.Name = "FreezePosition"
            bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bp.P = 1e5
            bp.D = 1000
            bp.Position = position or hrp.Position
            bp.Parent = hrp
        end)
        return true
    end
    return false
end

local function unfreezePlayer()
    pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local bp = char.HumanoidRootPart:FindFirstChild("FreezePosition")
            if bp then bp:Destroy() end
        end
    end)
end

local function isSafe(pos)
    local rayOrigin = pos + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return result ~= nil
end

-- Verificação de minigames
local function isSakuraMinigameActive()
    local success, result = pcall(function()
        return Workspace:FindFirstChild("Interiors")
            and Workspace.Interiors:FindFirstChild("BlossomShakedownInterior")
            and Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
            and #Workspace.Interiors.BlossomShakedownInterior.RingPickups:GetChildren() > 0
    end)
    return success and result or false
end

local function isTearUpMinigameActive()
    for _, interior in pairs(workspace.Interiors:GetChildren()) do
        if interior.Name:match("^KaijuStompMinigame::") then
            return true
        end
    end
    return false
end

local function isAnyMinigameActive()
    return isSakuraMinigameActive() or isTearUpMinigameActive()
end

-- Funções específicas para Sakura Swoop
local function cleanupSakuraPlatform()
    pcall(function()
        for _, part in ipairs(sakuraPlatformParts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
    end)
    sakuraPlatformParts = {}
end

local function createSakuraSafePlatform(center)
    cleanupSakuraPlatform()
    if typeof(center) ~= "Vector3" then return end
    local platformSize = Vector3.new(30, 1, 30)
    local wallHeight = 20
    local wallThickness = 1
    local function makePart(size, pos)
        local success, part = pcall(function()
            local p = Instance.new("Part")
            p.Size = size
            p.Position = pos
            p.Anchored = true
            p.Material = Enum.Material.SmoothPlastic
            p.BrickColor = BrickColor.new("Medium stone grey")
            p.CanCollide = true
            p.Transparency = 0.5
            p.Parent = Workspace
            return p
        end)
        if success and part then
            table.insert(sakuraPlatformParts, part)
            return part
        end
        return nil
    end
    makePart(platformSize, center - Vector3.new(0, 0.5, 0))
    makePart(platformSize, center + Vector3.new(0, wallHeight, 0))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, -platformSize.Z/2))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, platformSize.Z/2))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(-platformSize.X/2, wallHeight/2, 0))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(platformSize.X/2, wallHeight/2, 0))
end

local function getRingPickupsFolder()
    local success, result = pcall(function()
        return Workspace.Interiors.BlossomShakedownInterior.RingPickups
    end)
    return success and result or nil
end

local function sakuraPullModelsLoop()
    if sakuraCollectionComplete then
        print("Sakura: Coleta já concluída. Esperando o minigame terminar.")
        return
    end
    print("Sakura: Iniciando coleta de models. Limite: " .. sakuraMaxModelsToCollect)
    sakuraTotalModelsPulled = 0
    while sakuraRunning and isSakuraMinigameActive() and sakuraTotalModelsPulled < sakuraMaxModelsToCollect do
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then 
            task.wait(0.5)
            continue 
        end
        local folder = getRingPickupsFolder()
        if not folder then
            task.wait(0.2)
            continue
        end
        pcall(function()
            for _, model in ipairs(folder:GetChildren()) do
                if not sakuraRunning or not isSakuraMinigameActive() or sakuraTotalModelsPulled >= sakuraMaxModelsToCollect then 
                    break 
                end
                if model:IsA("Model") and model.Name == "Model" then
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                    if part then
                        model:SetPrimaryPartCFrame(char.HumanoidRootPart.CFrame)
                        sakuraTotalModelsPulled = sakuraTotalModelsPulled + 1
                        print("Sakura: Model trazido: " .. sakuraTotalModelsPulled .. "/" .. sakuraMaxModelsToCollect)
                        task.wait(0.5)
                    end
                end
            end
        end)
        task.wait(1)
    end
    sakuraCollectionComplete = true
    print("Sakura: Coleta de models finalizada. Total coletado: " .. sakuraTotalModelsPulled)
end

-- Funções específicas para Tear Up Toykyo
local function getTrees()
    local trees = {}
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("Model") and v.Name == "Tree1" then
            table.insert(trees, v)
        end
    end
    return trees
end

local function teleportToTrees()
    local trees = getTrees()
    while tearUpRunning and isTearUpMinigameActive() do
        for _, tree in ipairs(trees) do
            if not tearUpRunning or not isTearUpMinigameActive() then break end
            local cf = tree:GetModelCFrame()
            if isSafe(cf.Position) then
                teleportPlayer(cf.Position + Vector3.new(0, 3, 0))
                task.wait(0.25)
            end
        end
        task.wait(0.5)
    end
end

-- Funções para verificar timer
local function getTimerSeconds(timerLabel)
    if not timerLabel or not timerLabel:IsA("TextLabel") then return nil end
    local text = timerLabel.Text
    if not text or text == "" then return nil end
    local minutes, seconds = text:match("(%d+):(%d+)")
    if minutes and seconds then
        return tonumber(minutes) * 60 + tonumber(seconds)
    end
    return nil
end

local function checkTimers()
    local sakuraSeconds = getTimerSeconds(sakuraTimerLabel)
    local tearUpSeconds = getTimerSeconds(tearUpTimerLabel)
    return sakuraSeconds, tearUpSeconds
end

-- Funções principais
local function startSakuraAutofarm()
    while sakuraRunning do
        if isSakuraMinigameActive() then
            state = "IN_MINIGAME"
            inAnyMinigame = true
            if not sakuraCollectionComplete then
                sakuraTotalModelsPulled = 0
                sakuraCollectionComplete = false
                teleportPlayer(sakuraFirstPosition)
                task.wait(1)
                teleportPlayer(sakuraSecondPosition)
                createSakuraSafePlatform(sakuraSecondPosition)
                task.wait(0.3)
                simulateJump()
                task.wait(0.3)
                freezePlayer()
                sakuraPullModelsLoop()
            end
            task.wait(1)
        else
            unfreezePlayer()
            cleanupSakuraPlatform()
            state = "WAITING"
            inAnyMinigame = false
            task.wait(1)
        end
    end
end

local function startTearUpAutofarm()
    while tearUpRunning do
        if isTearUpMinigameActive() then
            state = "IN_MINIGAME"
            inAnyMinigame = true
            teleportToTrees()
            teleportPlayer(safeReturnPos)
            task.wait(2)
            state = "WAITING"
            inAnyMinigame = false
        else
            task.wait(1)
        end
    end
end

local function teleportToJoinZone(minigame)
    if minigame == "sakura" then
        local joinZone = getSakuraJoinZonePath()
        if joinZone then
            teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
            print("Teleportado para zona de entrada Sakura Swoop")
        end
    elseif minigame == "tearup" then
        local joinZone = getTearUpJoinZonePath()
        if joinZone then
            teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
            print("Teleportado para zona de entrada Tear Up Toykyo")
        end
    end
end

local function startWaitingPositionCycle()
    while running do
        if state == "WAITING" then
            local sakuraSeconds, tearUpSeconds = checkTimers()
            if sakuraSeconds and sakuraSeconds <= 30 and (not tearUpSeconds or sakuraSeconds < tearUpSeconds) then
                state = "JOINING"
                teleportToJoinZone("sakura")
                if not sakuraRunning then
                    sakuraRunning = true
                    task.spawn(startSakuraAutofarm)
                end
            elseif tearUpSeconds and tearUpSeconds <= 30 then
                state = "JOINING"
                teleportToJoinZone("tearup")
                if not tearUpRunning then
                    tearUpRunning = true
                    task.spawn(startTearUpAutofarm)
                end
            else
                local currentWaitPos = waitingPositions[currentWaitingPositionIndex]
                print("Teleportando para posição de espera " .. currentWaitingPositionIndex)
                teleportPlayer(currentWaitPos.position)
                local remainingTime = currentWaitPos.waitTime
                while remainingTime > 0 and state == "WAITING" do
                    task.wait(1)
                    remainingTime = remainingTime - 1
                    local newSakuraSeconds, newTearUpSeconds = checkTimers()
                    if (newSakuraSeconds and newSakuraSeconds <= 30) or (newTearUpSeconds and newTearUpSeconds <= 30) then
                        break
                    end
                end
                currentWaitingPositionIndex = currentWaitingPositionIndex % #waitingPositions + 1
            end
        else
            task.wait(1)
        end
    end
end

-- Toggle principal para ativar/desativar todo o sistema
w1:Toggle("Autofarm Completo", "autocomp", false, function(toggled)
    running = toggled
    if toggled then
        print("=== AUTOFARM COMPLETO ATIVADO ===")
        currentWaitingPositionIndex = 1
        inAnyMinigame = isAnyMinigameActive()
        state = "WAITING"
        sakuraRunning = true
        tearUpRunning = true
        task.spawn(startWaitingPositionCycle)
    else
        print("=== AUTOFARM COMPLETO DESATIVADO ===")
        sakuraRunning = false
        tearUpRunning = false
        unfreezePlayer()
        cleanupSakuraPlatform()
    end
end)

w1:Button(
    "Anti-AFK",
    function()
local VirtualUser = game:GetService('VirtualUser')

game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AntiAFK loaded!",
    Text = "Enjoy!",
    Button1 = "OK",
    Duration = 5
})
end
)

w1:Button(
    "Destroy GUI",
    function()
        for i, v in pairs(game.CoreGui:GetChildren()) do
            if v:FindFirstChild("Top") then
                v:Destroy()
            end
        end
    end
) -- Text, Callback

w1:Label("0 x 3 7") -- Text
