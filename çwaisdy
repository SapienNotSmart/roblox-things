
local library = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))() -- aonde a library vai ficar armazenada

local w1 = library:Window("a") -- Text

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Configurações gerais
local waitingPositions = {
    {position = Vector3.new(95, 38, -1327), waitTime = 15},
    {position = Vector3.new(71, 70, -1538), waitTime = 5}
}
local safeReturnPos = Vector3.new(112, 41, -1365)

-- Variáveis para controle do script
local running = false
local currentWaitingPositionIndex = 1
local waitingTimer = 0
local inAnyMinigame = false
local checkingForMinigames = true

-- Configurações Sakura Swoop
local sakuraRunning = false
local sakuraPlatformParts = {}
local sakuraTotalModelsPulled = 0
local sakuraMaxModelsToCollect = 40
local sakuraCollectionComplete = false
local sakuraMinigameJustEnded = false
local sakuraFirstPosition = Vector3.new(-2968, 5502, 11817)
local sakuraSecondPosition = Vector3.new(-3041, 5529, 11928)

-- Configurações Tear Up Toykyo
local tearUpRunning = false

-- Debug
local function debugPrint(message)
    print("[DEBUG] " .. message)
end

-- Funções utilitárias
local function teleportPlayer(pos)
    if typeof(pos) ~= "Vector3" then 
        debugPrint("Posição inválida para teleporte")
        return false 
    end
    
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            debugPrint("Teleportando para: " .. tostring(pos))
            char.HumanoidRootPart.CFrame = CFrame.new(pos)
            for i = 1, 3 do
                task.wait(0.1)
                char.HumanoidRootPart.CFrame = CFrame.new(pos)
            end
        end)
        return true
    end
    debugPrint("Falha ao teleportar: Personagem ou HumanoidRootPart não encontrado")
    return false
end

local function simulateJump()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        pcall(function()
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end)
        return true
    end
    return false
end

local function freezePlayer(position)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    if not hrp:FindFirstChild("FreezePosition") then
        pcall(function()
            local bp = Instance.new("BodyPosition")
            bp.Name = "FreezePosition"
            bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bp.P = 1e5
            bp.D = 1000
            bp.Position = position or hrp.Position
            bp.Parent = hrp
        end)
        return true
    end
    return false
end

local function unfreezePlayer()
    pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local bp = char.HumanoidRootPart:FindFirstChild("FreezePosition")
            if bp then bp:Destroy() end
        end
    end)
end

local function isSafe(pos)
    local rayOrigin = pos + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return result ~= nil
end

local function teleportTo(pos, ignoreSafety)
    if ignoreSafety or isSafe(pos) then
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
            return true
        end
    end
    return false
end

-- Path dos timers e funções para acessá-los
local function getSakuraTimerLabel()
    return Workspace:FindFirstChild("Interiors") 
        and Workspace.Interiors:FindFirstChild("MainMap!Default")
        and Workspace.Interiors["MainMap!Default"]:FindFirstChild("BlossomShakedownJoinZone")
        and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone:FindFirstChild("Billboard")
        and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Billboard:FindFirstChild("BillboardGui")
        and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Billboard.BillboardGui:FindFirstChild("TimerLabel")
end

local function getTearUpTimerLabel()
    return Workspace:FindFirstChild("Interiors") 
        and Workspace.Interiors:FindFirstChild("MainMap!Default")
        and Workspace.Interiors["MainMap!Default"]:FindFirstChild("TearUpToykyoJoinZone")
        and Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone:FindFirstChild("Billboard")
        and Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Billboard:FindFirstChild("BillboardGui")
        and Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Billboard.BillboardGui:FindFirstChild("TimerLabel")
end

-- Path das join zones
local function getSakuraJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("BlossomShakedownJoinZone") 
    and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Collider
    end
    return nil
end

local function getTearUpJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("TearUpToykyoJoinZone") 
    and Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Collider
    end
    return nil
end

-- Verificação de minigames
local function isSakuraMinigameActive()
    local success, result = pcall(function()
        return Workspace:FindFirstChild("Interiors")
            and Workspace.Interiors:FindFirstChild("BlossomShakedownInterior")
            and Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
            and #Workspace.Interiors.BlossomShakedownInterior.RingPickups:GetChildren() > 0
    end)
    return success and result or false
end

local function isTearUpMinigameActive()
    for _, interior in pairs(workspace.Interiors:GetChildren()) do
        if interior.Name:match("^KaijuStompMinigame::") then
            return true
        end
    end
    return false
end

local function isAnyMinigameActive()
    return isSakuraMinigameActive() or isTearUpMinigameActive()
end

-- Funções específicas para Sakura Swoop
local function cleanupSakuraPlatform()
    pcall(function()
        for _, part in ipairs(sakuraPlatformParts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
    end)
    sakuraPlatformParts = {}
end

local function createSakuraSafePlatform(center)
    cleanupSakuraPlatform()
    
    if typeof(center) ~= "Vector3" then return end
    
    local platformSize = Vector3.new(30, 1, 30)
    local wallHeight = 20
    local wallThickness = 1

    local function makePart(size, pos)
        local success, part = pcall(function()
            local p = Instance.new("Part")
            p.Size = size
            p.Position = pos
            p.Anchored = true
            p.Material = Enum.Material.SmoothPlastic
            p.BrickColor = BrickColor.new("Medium stone grey")
            p.CanCollide = true
            p.Transparency = 0.5
            p.Parent = Workspace
            return p
        end)
        
        if success and part then
            table.insert(sakuraPlatformParts, part)
            return part
        end
        return nil
    end

    makePart(platformSize, center - Vector3.new(0, 0.5, 0))
    makePart(platformSize, center + Vector3.new(0, wallHeight, 0))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, -platformSize.Z/2))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, platformSize.Z/2))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(-platformSize.X/2, wallHeight/2, 0))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(platformSize.X/2, wallHeight/2, 0))
end

local function getRingPickupsFolder()
    local success, result = pcall(function()
        return Workspace.Interiors.BlossomShakedownInterior.RingPickups
    end)
    return success and result or nil
end

local function sakuraPullModelsLoop()
    if sakuraCollectionComplete then
        debugPrint("Sakura: Coleta já concluída. Esperando o minigame terminar.")
        return
    end
    
    debugPrint("Sakura: Iniciando coleta de models. Limite: " .. sakuraMaxModelsToCollect)
    sakuraTotalModelsPulled = 0
    
    while sakuraRunning and isSakuraMinigameActive() and sakuraTotalModelsPulled < sakuraMaxModelsToCollect do
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then 
            task.wait(0.5)
            continue 
        end

        local folder = getRingPickupsFolder()
        if not folder then
            task.wait(0.2)
            continue
        end

        if sakuraTotalModelsPulled >= sakuraMaxModelsToCollect then
            break
        end

        pcall(function()
            for _, model in ipairs(folder:GetChildren()) do
                if not sakuraRunning or sakuraTotalModelsPulled >= sakuraMaxModelsToCollect then 
                    break 
                end
                
                if model:IsA("Model") and model.Name == "Model" then
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                    if part then
                        model:SetPrimaryPartCFrame(char.HumanoidRootPart.CFrame)
                        sakuraTotalModelsPulled = sakuraTotalModelsPulled + 1
                        debugPrint("Sakura: Model trazido: " .. sakuraTotalModelsPulled .. "/" .. sakuraMaxModelsToCollect)
                        
                        task.wait(0.5)
                        
                        if sakuraTotalModelsPulled >= sakuraMaxModelsToCollect then
                            debugPrint("Sakura: Limite de " .. sakuraMaxModelsToCollect .. " models atingido. Parando.")
                            sakuraCollectionComplete = true
                            break
                        end
                    end
                end
            end
        end)
        
        if sakuraTotalModelsPulled >= sakuraMaxModelsToCollect then
            sakuraCollectionComplete = true
            break
        end
        
        task.wait(1)
    end
    
    sakuraCollectionComplete = true
    debugPrint("Sakura: Coleta de models finalizada. Total coletado: " .. sakuraTotalModelsPulled)
end

-- Funções específicas para Tear Up Toykyo
local function teleportToTrees()
    while isTearUpMinigameActive() and tearUpRunning do
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Model") and v.Name == "Tree1" then
                local cf = v:GetModelCFrame()
                local targetPos = cf.Position
                if isSafe(targetPos) then
                    local char = LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = cf + Vector3.new(0, 3, 0)
                        task.wait(0.25)
                    end
                end
            end
        end
        task.wait(0.5)
    end
end

-- Funções para verificar timer
local function getTimerSeconds(timerLabel)
    if not timerLabel then return nil end
    
    local text = timerLabel.Text
    if not text then return nil end
    
    -- Verificar se o formato é "PRÓXIMO JOGO EM:\nMM:SS"
    local minutes, seconds = string.match(text, "PRÓXIMO JOGO EM:\n(%d+):(%d+)")
    
    if minutes and seconds then
        return tonumber(minutes) * 60 + tonumber(seconds)
    end
    
    return nil
end

-- Funções principais
local function startSakuraAutofarm()
    local wasInMinigame = false
    
    while sakuraRunning do
        local minigameActive = isSakuraMinigameActive()
        
        -- Detectar quando o minigame acabou de terminar
        if wasInMinigame and not minigameActive then
            sakuraMinigameJustEnded = true
            debugPrint("Sakura: Minigame acabou de terminar.")
        end
        wasInMinigame = minigameActive

        if not minigameActive then
            -- Se o minigame acabou de terminar, esperar 10 segundos
            if sakuraMinigameJustEnded then
                debugPrint("Sakura: Esperando período de estabilização após minigame...")
                unfreezePlayer()
                cleanupSakuraPlatform()
                
                -- Esperar 10 segundos antes de teleportar
                for i = 1, 10 do
                    if not sakuraRunning then break end
                    debugPrint("Sakura: Aguardando: " .. i .. "/10 segundos")
                    task.wait(1)
                end
                
                sakuraMinigameJustEnded = false
                debugPrint("Sakura: Período de espera concluído")
                inAnyMinigame = false
            end
            
            -- Resetar variáveis quando não estiver no minigame
            sakuraTotalModelsPulled = 0
            sakuraCollectionComplete = false
            
            task.wait(2)
        else
            -- Só executa o setup e coleta se ainda não tiver coletado
            if not sakuraCollectionComplete then
                -- Resetar contadores para o novo minigame
                sakuraTotalModelsPulled = 0
                sakuraCollectionComplete = false
                sakuraMinigameJustEnded = false
                inAnyMinigame = true
                
                teleportPlayer(sakuraFirstPosition)
                task.wait(1)

                teleportPlayer(sakuraSecondPosition)
                createSakuraSafePlatform(sakuraSecondPosition)
                task.wait(0.3)

                simulateJump()
                task.wait(0.3)

                freezePlayer()

                -- Executar a coleta uma única vez
                sakuraPullModelsLoop()
            end

            -- Verificar se o minigame ainda está ativo
            if isSakuraMinigameActive() then
                -- Continuar esperando na plataforma segura
                task.wait(3)
            else
                -- Não fazer nada aqui - deixar o loop detectar o fim do minigame
                -- na próxima iteração para acionar o delay
                task.wait(1)
            end
        end

        task.wait(1)
    end
end

local function startTearUpAutofarm()
    while tearUpRunning do
        if isTearUpMinigameActive() then
            inAnyMinigame = true
            teleportToTrees()
            repeat task.wait() until not isTearUpMinigameActive() or not tearUpRunning
            
            -- Proteção contra void: volta pra zona segura logo após o minigame
            teleportTo(safeReturnPos, true) 
            task.wait(2)
            inAnyMinigame = false
        else
            task.wait(1)
        end
    end
end

-- Função principal para monitorar os timers e gerenciar teleportes
local function monitorMinigameTimers()
    while checkingForMinigames and running do
        -- Verificar se já estamos em um minigame
        if isAnyMinigameActive() or inAnyMinigame then
            task.wait(1)
            continue
        end
        
        -- Obter os TimerLabels diretamente
        local sakuraTimerLabel = getSakuraTimerLabel()
        local tearUpTimerLabel = getTearUpTimerLabel()
        
        -- Obter os segundos dos timers
        local sakuraSeconds = sakuraTimerLabel and getTimerSeconds(sakuraTimerLabel)
        local tearUpSeconds = tearUpTimerLabel and getTimerSeconds(tearUpTimerLabel)
        
        -- Debug dos timers
        if sakuraSeconds then
            debugPrint("Timer Sakura: " .. sakuraSeconds .. " segundos")
        end
        
        if tearUpSeconds then
            debugPrint("Timer Tear Up: " .. tearUpSeconds .. " segundos")
        end
        
        -- Verificar timers para teleportar
        if sakuraSeconds and sakuraSeconds <= 30 then
            debugPrint("⚠️ Sakura Swoop prestes a começar! Teleportando para zona de entrada.")
            local joinZone = getSakuraJoinZonePath()
            if joinZone then
                teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
                
                -- Ativar o Sakura autofarm se não estiver ativo
                if not sakuraRunning then
                    sakuraRunning = true
                    task.spawn(startSakuraAutofarm)
                end
                
                -- Esperar até que o minigame comece
                local waitTime = 0
                while waitTime < 35 and not isSakuraMinigameActive() do
                    task.wait(1)
                    waitTime = waitTime + 1
                end
            end
        elseif tearUpSeconds and tearUpSeconds <= 30 then
            debugPrint("⚠️ Tear Up Toykyo prestes a começar! Teleportando para zona de entrada.")
            local joinZone = getTearUpJoinZonePath()
            if joinZone then
                teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
                
                -- Ativar o Tear Up autofarm se não estiver ativo
                if not tearUpRunning then
                    tearUpRunning = true
                    task.spawn(startTearUpAutofarm)
                end
                
                -- Esperar até que o minigame comece
                local waitTime = 0
                while waitTime < 35 and not isTearUpMinigameActive() do
                    task.wait(1)
                    waitTime = waitTime + 1
                end
            end
        end
        
        task.wait(1)  -- Verificar timers a cada segundo
    end
end

local function startWaitingPositionCycle()
    while running do
        -- Não executar se estiver em algum minigame ou prestes a entrar em um
        if isAnyMinigameActive() or inAnyMinigame then
            task.wait(1)
            continue
        end
        
        -- Ciclo entre posições de espera
        local currentWaitPos = waitingPositions[currentWaitingPositionIndex]
        
        debugPrint("Teleportando para posição de espera " .. currentWaitingPositionIndex)
        teleportPlayer(currentWaitPos.position)
        
        -- Esperar o tempo designado para esta posição
        local remainingTime = currentWaitPos.waitTime
        while remainingTime > 0 and running and not isAnyMinigameActive() and not inAnyMinigame do
            task.wait(1)
            remainingTime = remainingTime - 1
        end
        
        -- Avançar para a próxima posição se não estiver em um minigame
        if not isAnyMinigameActive() and not inAnyMinigame then
            currentWaitingPositionIndex = currentWaitingPositionIndex % #waitingPositions + 1
        end
    end
end

-- Toggle único para controle completo
w1:Toggle("Autofarm", "autocomp", false, function(toggled)
    running = toggled
    
    if toggled then
        -- Inicializar variáveis
        currentWaitingPositionIndex = 1
        waitingTimer = 0
        inAnyMinigame = false
        checkingForMinigames = true
        
        -- Iniciar o monitoramento de timers e o ciclo de posições de espera
        task.spawn(monitorMinigameTimers)
        task.spawn(startWaitingPositionCycle)
        
        -- Configurar para iniciar os autofarms conforme necessário
        sakuraRunning = true
        tearUpRunning = true
        
        debugPrint("Sistema de autofarm completo iniciado!")
    else
        -- Desativar todos os subsistemas
        checkingForMinigames = false
        sakuraRunning = false
        tearUpRunning = false
        
        -- Limpar plataformas e descongelar jogador
        unfreezePlayer()
        cleanupSakuraPlatform()
        
        debugPrint("Sistema de autofarm completo desativado!")
    end
end)

w1:Button(
    "Anti-AFK",
    function()
local VirtualUser = game:GetService('VirtualUser')

game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AntiAFK loaded!",
    Text = "Enjoy!",
    Button1 = "OK",
    Duration = 5
})
end
)

w1:Button(
    "Destroy GUI",
    function()
        for i, v in pairs(game.CoreGui:GetChildren()) do
            if v:FindFirstChild("Top") then
                v:Destroy()
            end
        end
    end
) -- Text, Callback

w1:Label("0 x 3 7") -- Text
