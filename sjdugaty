local TeleportService = game:GetService("TeleportService")

-- Hook na função Teleport para evitar que o jogo force um rejoin
local oldTeleport; oldTeleport = hookfunction(TeleportService.Teleport, function(...)
    warn("Blyadddd")
    return -- Cancela a execução da função
end)

-- Hook na função TeleportToPlaceInstance
local oldTeleportInstance; oldTeleportInstance = hookfunction(TeleportService.TeleportToPlaceInstance, function(...)
    warn("Kurwaaaa")
    return -- Cancela a execução da função
end)

print("Rejoin protection enabled")

local library = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))() -- aonde a library vai ficar armazenada

local w1 = library:Window("Cherry Blossom Festival") -- Text

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local waitPos = Vector3.new(30, 31, -1499)
local sakuraFarmRunning = false
local kaijuFarmRunning = false
local farmEnabled = false
local inGameSince = 0

-- Proteção contra void
local function isSafe(pos)
	local rayOrigin = pos + Vector3.new(0, 5, 0)
	local rayDirection = Vector3.new(0, -100, 0)
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {char}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	local result = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
	return result ~= nil
end

-- Parse Timer
local function parseTimer(text)
	if not text then return math.huge end

	local mm, ss = text:match("(%d+):(%d+)")
	if mm and ss then
		return tonumber(mm) * 60 + tonumber(ss)
	end

	return math.huge
end

-- Detecta minigame ativo
local function isSakuraActive()
	return Workspace:FindFirstChild("Interiors")
		and Workspace.Interiors:FindFirstChild("BlossomShakedownInterior")
		and Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
end

local function isKaijuActive()
	if not Workspace:FindFirstChild("Interiors") then return false end
	for _, v in ipairs(Workspace.Interiors:GetChildren()) do
		if v.Name:match("^KaijuStompMinigame::") then
			return true
		end
	end
	return false
end

-- Autofarm Sakura
local function startSakuraFarm()
    if sakuraFarmRunning then return end
    sakuraFarmRunning = true
    
    local firstPos = Vector3.new(-2968, 5502, 11817)
    local secondPos = Vector3.new(-3041, 5529, 11928)
    local collected = 0
    local maxModels = 40
    local collectedModels = {}
    
    -- Teleporta para a área e espera
    hrp.CFrame = CFrame.new(firstPos)
    task.wait(1)
    hrp.CFrame = CFrame.new(secondPos)
    task.wait(0.5)
    
    -- Congela o jogador
    local freeze = Instance.new("BodyPosition")
    freeze.Name = "Freeze"
    freeze.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    freeze.Position = hrp.Position
    freeze.P = 1e5
    freeze.D = 1e4
    freeze.Parent = hrp
    
    local startTime = os.time()
    local maxWaitTime = 60 -- Tempo máximo em segundos para tentar coletar
    
    while isSakuraActive() and collected < maxModels and (os.time() - startTime) < maxWaitTime do
        local folder = Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
        
        if folder then
            local models = folder:GetChildren()
            local foundNew = false
            
            for _, model in ipairs(models) do
                if model:IsA("Model") and model.Name == "Model" and not collectedModels[model] then
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                    
                    if part then
                        if collected >= maxModels then
                            break
                        end
                        
                        model:SetPrimaryPartCFrame(hrp.CFrame)
                        collectedModels[model] = true
                        collected = collected + 1
                        foundNew = true
                        print("Sakura: " .. collected .. "/" .. maxModels)
                        task.wait(0.3)
                    end
                end
            end
            
            -- Se não encontramos nenhum novo modelo e ainda não coletamos o suficiente
            if not foundNew and collected < maxModels then
                -- Espera um pouco mais para ver se novos modelos aparecem
                task.wait(1)
            end
        else
            task.wait(1) -- Espera caso a pasta não seja encontrada
        end
    end
    
    print("Coleta finalizada: " .. collected .. " modelos coletados de " .. maxModels .. " desejados")
    
    -- Libera o personagem e volta para posição de espera
    freeze:Destroy()
    hrp.CFrame = CFrame.new(waitPos)
    sakuraFarmRunning = false
end


-- Autofarm Kaiju
local function startKaijuFarm()
	if kaijuFarmRunning then return end
	kaijuFarmRunning = true

	while isKaijuActive() do
		for _, v in ipairs(Workspace:GetDescendants()) do
			if v:IsA("Model") and v.Name == "Tree1" then
				local cf = v:GetModelCFrame()
				local pos = cf.Position
				if isSafe(pos) then
					hrp.CFrame = cf + Vector3.new(0, 3, 0)
					task.wait(0.25)
				end
			end
		end
		task.wait(0.5)
	end

	hrp.CFrame = CFrame.new(waitPos)
	kaijuFarmRunning = false
end

-- Loop principal
task.spawn(function()
	while true do
		if not farmEnabled then task.wait(1) continue end

		local interiors = Workspace:FindFirstChild("Interiors")
		local mainMap = interiors and interiors:FindFirstChild("MainMap!Default")

		local sakuraTime = math.huge
		local kaijuTime = math.huge

		if mainMap then
			local sakuraLabel = mainMap:FindFirstChild("BlossomShakedownJoinZone")
			if sakuraLabel and sakuraLabel:FindFirstChild("Billboard") then
				local label = sakuraLabel.Billboard:FindFirstChild("BillboardGui")
				if label and label:FindFirstChild("TimerLabel") then
					sakuraTime = parseTimer(label.TimerLabel.Text or label.TimerLabel.ContentText)
				end
			end

			local kaijuLabel = mainMap:FindFirstChild("TearUpToykyoJoinZone")
			if kaijuLabel and kaijuLabel:FindFirstChild("Billboard") then
				local label = kaijuLabel.Billboard:FindFirstChild("BillboardGui")
				if label and label:FindFirstChild("TimerLabel") then
					kaijuTime = parseTimer(label.TimerLabel.Text or label.TimerLabel.ContentText)
				end
			end
		end

		if isSakuraActive() then
			inGameSince = os.clock()
			startSakuraFarm()
		elseif isKaijuActive() then
			inGameSince = os.clock()
			startKaijuFarm()
		elseif sakuraTime <= 35 or kaijuTime <= 35 then
			if os.clock() - inGameSince > 10 then
				if sakuraTime < kaijuTime then
					local pos = mainMap.BlossomShakedownJoinZone.Collider.Position + Vector3.new(0, 3, 0)
					if isSafe(pos) then
						hrp.CFrame = CFrame.new(pos)
					end
				else
					local pos = mainMap.TearUpToykyoJoinZone.Collider.Position + Vector3.new(0, 3, 0)
					if isSafe(pos) then
						hrp.CFrame = CFrame.new(pos)
					end
				end
			end
		else
			if os.clock() - inGameSince > 10 then
				if (hrp.Position - waitPos).Magnitude > 5 then
					hrp.CFrame = CFrame.new(waitPos)
				end
			end
		end

		task.wait(1)
	end
end)

-- Toggle
w1:Toggle(
	"Farm Both Minigames",
	"frz",
	false,
	function(toggled)
		farmEnabled = toggled
	end
)

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

local firstPosition = Vector3.new(-2968, 5502, 11817)
local secondPosition = Vector3.new(-3041, 5529, 11928)
local afkPosition = Vector3.new(76, 38, -1322)
local afkWalkPosition = Vector3.new(99, 39, -1328)
local antiAfkPos = Vector3.new(55, 31, -1466) -- Posição para evitar detecção de AFK

local running = false
local platformParts = {}
local totalModelsPulled = 0
local maxModelsToCollect = 40
local collectionComplete = false

local function getTimeUntilMinigame()
    local success, result = pcall(function()
        local label = Workspace.Interiors["MainMap!Default"]
            .BlossomShakedownJoinZone
            .Billboard
            .BillboardGui
            .TimerLabel

        if label and label.ContentText then
            local minutes, seconds = string.match(label.ContentText, "(%d+):(%d+)")
            if minutes and seconds then
                return tonumber(minutes) * 60 + tonumber(seconds)
            end
        end
        return nil
    end)
    return success and result or nil
end

local function getJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("BlossomShakedownJoinZone") 
    and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Collider
    end
    return nil
end

local function teleportPlayer(pos)
    if typeof(pos) ~= "Vector3" then return false end
    
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            char.HumanoidRootPart.CFrame = CFrame.new(pos)
            for i = 1, 3 do
                task.wait(0.1)
                char.HumanoidRootPart.CFrame = CFrame.new(pos)
            end
        end)
        return true
    end
    return false
end

local function moveToPosition(pos)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") and char:FindFirstChild("HumanoidRootPart") then
        char.Humanoid:MoveTo(pos)
        char.Humanoid.MoveToFinished:Wait()
    end
end

local function simulateJump()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        pcall(function()
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end)
        return true
    end
    return false
end

local function freezePlayer(position)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    if not hrp:FindFirstChild("FreezePosition") then
        pcall(function()
            local bp = Instance.new("BodyPosition")
            bp.Name = "FreezePosition"
            bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bp.P = 1e5
            bp.D = 1000
            bp.Position = position or hrp.Position
            bp.Parent = hrp
        end)
        return true
    end
    return false
end

local function unfreezePlayer()
    pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local bp = char.HumanoidRootPart:FindFirstChild("FreezePosition")
            if bp then bp:Destroy() end
        end
    end)
end

local function cleanupPlatform()
    pcall(function()
        for _, part in ipairs(platformParts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
    end)
    platformParts = {}
end

local function createSafePlatform(center)
    cleanupPlatform()
    
    if typeof(center) ~= "Vector3" then return end
    
    local platformSize = Vector3.new(30, 1, 30)
    local wallHeight = 20
    local wallThickness = 1

    local function makePart(size, pos)
        local success, part = pcall(function()
            local p = Instance.new("Part")
            p.Size = size
            p.Position = pos
            p.Anchored = true
            p.Material = Enum.Material.SmoothPlastic
            p.BrickColor = BrickColor.new("Medium stone grey")
            p.CanCollide = true
            p.Transparency = 0.5
            p.Parent = Workspace
            return p
        end)
        
        if success and part then
            table.insert(platformParts, part)
            return part
        end
        return nil
    end

    makePart(platformSize, center - Vector3.new(0, 0.5, 0))
    makePart(platformSize, center + Vector3.new(0, wallHeight, 0))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, -platformSize.Z/2))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, platformSize.Z/2))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(-platformSize.X/2, wallHeight/2, 0))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(platformSize.X/2, wallHeight/2, 0))
end

local function isMinigameActive()
    local success, result = pcall(function()
        return Workspace:FindFirstChild("Interiors")
            and Workspace.Interiors:FindFirstChild("BlossomShakedownInterior")
            and Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
            and #Workspace.Interiors.BlossomShakedownInterior.RingPickups:GetChildren() > 0
    end)
    return success and result or false
end

local function getRingPickupsFolder()
    local success, result = pcall(function()
        return Workspace.Interiors.BlossomShakedownInterior.RingPickups
    end)
    return success and result or nil
end

local function pullModelsLoop()
    if collectionComplete then
        print("Coleta já concluída. Esperando o minigame terminar.")
        return
    end
    
    print("Iniciando coleta de models. Limite: " .. maxModelsToCollect)
    totalModelsPulled = 0
    
    while running and isMinigameActive() and totalModelsPulled < maxModelsToCollect do
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then 
            task.wait(0.5)
            continue 
        end

        local folder = getRingPickupsFolder()
        if not folder then
            task.wait(0.2)
            continue
        end

        if totalModelsPulled >= maxModelsToCollect then
            break
        end

        pcall(function()
            for _, model in ipairs(folder:GetChildren()) do
                if not running or totalModelsPulled >= maxModelsToCollect then 
                    break 
                end
                
                if model:IsA("Model") and model.Name == "Model" then
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                    if part then
                        model:SetPrimaryPartCFrame(char.HumanoidRootPart.CFrame)
                        totalModelsPulled = totalModelsPulled + 1
                        print("Model trazido: " .. totalModelsPulled .. "/" .. maxModelsToCollect)
                        
                        task.wait(0.5)
                        
                        if totalModelsPulled >= maxModelsToCollect then
                            print("Limite de " .. maxModelsToCollect .. " models atingido. Parando.")
                            collectionComplete = true
                            break
                        end
                    end
                end
            end
        end)
        
        if totalModelsPulled >= maxModelsToCollect then
            collectionComplete = true
            break
        end
        
        task.wait(1)
    end
    
    collectionComplete = true
    print("Coleta de models finalizada. Total coletado: " .. totalModelsPulled)
end

-- Sistema Anti-AFK
local function startAntiAfkSystem()
    task.spawn(function()
        local lastAntiAfkTime = 0
        
        while running do
            local currentTime = tick()
            -- Verificar se já passou 15 segundos desde a última ação anti-AFK
            if currentTime - lastAntiAfkTime >= 15 and not isMinigameActive() then
                print("Executando ação anti-AFK")
                
                -- Salva a posição atual antes de teleportar
                local char = LocalPlayer.Character
                local currentPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position or afkPosition
                
                -- Teleporta para a posição anti-AFK
                teleportPlayer(antiAfkPos)
                print("Teleportado para posição anti-AFK")
                
                -- Espera 5 segundos
                for i = 1, 5 do
                    if not running then break end
                    task.wait(1)
                end
                
                -- Retorna para a posição original (zona AFK)
                teleportPlayer(afkPosition)
                print("Voltou para a zona AFK")
                
                -- Reinicia o timer
                lastAntiAfkTime = tick()
            end
            
            task.wait(1)
        end
    end)
end

local function stayAFKLoop()
    local lastWalkTime = 0
    
    while running and not isMinigameActive() do
        local currentTime = tick()
        local timeLeft = getTimeUntilMinigame()
        
        if not timeLeft or timeLeft <= 30 then 
            break 
        end
        
        -- Verificar se não estamos no meio de uma ação anti-AFK
        if currentTime - lastWalkTime >= 5 then
            moveToPosition(afkWalkPosition)
            task.wait(0.5)
            moveToPosition(afkPosition)
            
            lastWalkTime = tick()
        end

        task.wait(1)
    end
end

-- Variável para rastrear quando o minigame terminou
local minigameJustEnded = false

local function startAutofarm()
    local wasInMinigame = false
    
    while running do
        local minigameActive = isMinigameActive()
        
        -- Detectar quando o minigame acabou de terminar
        if wasInMinigame and not minigameActive then
            minigameJustEnded = true
            print("Minigame acabou de terminar. Aguardando 10 segundos antes de teleportar...")
        end
        wasInMinigame = minigameActive

        if not minigameActive then
            -- Se o minigame acabou de terminar, esperar 10 segundos
            if minigameJustEnded then
                print("Esperando período de estabilização após minigame...")
                unfreezePlayer()
                cleanupPlatform()
                
                -- Esperar 10 segundos antes de teleportar
                for i = 1, 10 do
                    if not running then break end
                    print("Aguardando: " .. i .. "/10 segundos")
                    task.wait(1)
                end
                
                minigameJustEnded = false
                print("Período de espera concluído, teleportando para área AFK")
            end
            
            -- Resetar variáveis quando não estiver no minigame
            totalModelsPulled = 0
            collectionComplete = false
            
            local timeLeft = getTimeUntilMinigame()
            if timeLeft and timeLeft <= 30 then
                local joinZone = getJoinZonePath()
                if joinZone then
                    teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
                end
            else
                teleportPlayer(afkPosition)
                task.spawn(stayAFKLoop)
            end

            task.wait(2)
        else
            -- Só executa o setup e coleta se ainda não tiver coletado
            if not collectionComplete then
                -- Resetar contadores para o novo minigame
                totalModelsPulled = 0
                collectionComplete = false
                minigameJustEnded = false
                
                teleportPlayer(firstPosition)
                task.wait(1)

                teleportPlayer(secondPosition)
                createSafePlatform(secondPosition)
                task.wait(0.3)

                simulateJump()
                task.wait(0.3)

                freezePlayer()

                -- Executar a coleta uma única vez
                pullModelsLoop()
            end

            -- Verificar se o minigame ainda está ativo
            if isMinigameActive() then
                -- Continuar esperando na plataforma segura
                task.wait(3)
            else
                -- Não fazer nada aqui - deixar o loop detectar o fim do minigame
                -- na próxima iteração para acionar o delay
                task.wait(1)
            end
        end

        task.wait(1)
    end
end

-- 🔘 Toggle com biblioteca w1 (substitua pela sua UI se necessário)
w1:Toggle("Sakura Swoop Autofarm", "maf", false, function(toggled)
    running = toggled

    if toggled then
        -- Resetar variáveis ao ligar o script
        totalModelsPulled = 0
        collectionComplete = false
        minigameJustEnded = false
        
        -- Iniciar o sistema anti-AFK
        startAntiAfkSystem()
        
        pcall(function()
            task.spawn(startAutofarm)
        end)
    else
        unfreezePlayer()
        cleanupPlatform()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local root = char:WaitForChild("HumanoidRootPart")
-- Config
local joinZone = workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Collider
local timerLabel = workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Billboard.BillboardGui.TimerLabel
local afkPath = {
    Vector3.new(125, 42, -1384),
    Vector3.new(136, 42, -1376),
    Vector3.new(112, 41, -1365)
}
local safeAfkReturnPos = Vector3.new(112, 41, -1365) -- posição segura após minigame
local antiAfkPos = Vector3.new(55, 31, -1466) -- posição para evitar detecção de afk

-- Void protection
local function isSafe(pos)
    local rayOrigin = pos + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return result ~= nil
end

local function teleportTo(pos, ignoreSafety)
    if ignoreSafety or isSafe(pos) then
        root.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
    end
end

local function walkPath(path)
    local humanoid = char:WaitForChild("Humanoid")
    for _, pos in ipairs(path) do
        humanoid:MoveTo(pos)
        humanoid.MoveToFinished:Wait()
        task.wait(0.2)
    end
end

local function isInMinigame()
    for _, interior in pairs(workspace.Interiors:GetChildren()) do
        if interior.Name:match("^KaijuStompMinigame::") then
            return true
        end
    end
    return false
end

local function teleportToTrees()
    while isInMinigame() and _G.kaijuAutofarm do
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Model") and v.Name == "Tree1" then
                local cf = v:GetModelCFrame()
                local targetPos = cf.Position
                if isSafe(targetPos) then
                    root.CFrame = cf + Vector3.new(0, 3, 0)
                    task.wait(0.25)
                end
            end
        end
        task.wait(0.5)
    end
end

local function afkRoutine()
    teleportTo(afkPath[#afkPath]) -- Vai até a posição inicial da rota
    walkPath({afkPath[1], afkPath[2], afkPath[3]}) -- Caminha pela rota
end

-- Sistema Anti-AFK
local function startAntiAfkSystem()
    task.spawn(function()
        local lastAntiAfkTime = 0
        while _G.kaijuAutofarm do
            local currentTime = tick()
            if currentTime - lastAntiAfkTime >= 15 and not isInMinigame() then  -- A cada 15 segundos e não estando no minigame
                -- Salva a posição atual antes de teleportar
                local currentPos = root.Position
                
                -- Teleporta para a posição anti-AFK
                teleportTo(antiAfkPos)
                task.wait(5)  -- Espera 5 segundos
                
                -- Retorna para a posição original (zona AFK)
                teleportTo(safeAfkReturnPos)
                
                -- Reinicia o timer
                lastAntiAfkTime = tick()
            end
            task.wait(1)
        end
    end)
end

w1:Toggle(
    "Kaiju Stomp Autofarm",
    "frz",
    false,
    function(toggled)
        if toggled then
            _G.kaijuAutofarm = true
            
            -- Inicia o sistema anti-AFK
            startAntiAfkSystem()
            
            -- Script principal de autofarm
            task.spawn(function()
                while _G.kaijuAutofarm do
                    if isInMinigame() then
                        teleportToTrees()
                        repeat task.wait() until not isInMinigame() or not _G.kaijuAutofarm
                        -- Proteção contra void: volta pra zona AFK logo após o minigame
                        teleportTo(safeAfkReturnPos, true) 
                        task.wait(7)
                    else
                        local timerText = timerLabel.Text:lower():gsub("[^%d]", "")
                        local seconds = tonumber(timerText) or 999
                        if seconds < 30 then
                            teleportTo(joinZone.Position)
                        else
                            afkRoutine()
                        end
                    end
                    task.wait(1)
                end
            end)
        else
            _G.kaijuAutofarm = false
        end
    end
)

w1:Button(
    "Anti-AFK",
    function()
local VirtualUser = game:GetService('VirtualUser')

game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AntiAFK loaded!",
    Text = "Enjoy!",
    Button1 = "OK",
    Duration = 5
})
end
)

w1:Label("YT: PabloScripts21") -- Text

w1:Button(
    "wanna support me?",
    function()
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")
        local player = Players.LocalPlayer
        local playerGui = player:FindFirstChild("PlayerGui")
        if not playerGui then return end

        -- Criar GUI principal
        local screenGui = Instance.new("ScreenGui", playerGui)
        screenGui.Name = "SupportPrompt"
        screenGui.ResetOnSpawn = false

        -- Frame principal
        local frame = Instance.new("Frame", screenGui)
        frame.Size = UDim2.new(0, 0, 0, 0) -- começa pequeno
        frame.Position = UDim2.new(0.5, -125, 0.4, 0)
        frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        frame.BackgroundTransparency = 0.2
        frame.BorderSizePixel = 0

        -- Arredondar bordas
        local corner = Instance.new("UICorner", frame)
        corner.CornerRadius = UDim.new(0, 12)

        -- Aparecer com animação
        TweenService:Create(frame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 300, 0, 160)
        }):Play()

        -- Título
        local title = Instance.new("TextLabel", frame)
        title.Size = UDim2.new(1, 0, 0.3, 0)
        title.Position = UDim2.new(0, 0, 0, 0)
        title.Text = "For real?"
        title.TextSize = 24
        title.Font = Enum.Font.GothamBold
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.BackgroundTransparency = 1

        -- Botões container
        local buttonHolder = Instance.new("Frame", frame)
        buttonHolder.Size = UDim2.new(1, 0, 0.5, 0)
        buttonHolder.Position = UDim2.new(0, 0, 0.5, 0)
        buttonHolder.BackgroundTransparency = 1

        local layout = Instance.new("UIListLayout", buttonHolder)
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 10)

        local function createButton(text, color)
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(0.45, 0, 1, 0)
            button.Text = text
            button.TextSize = 20
            button.Font = Enum.Font.GothamBold
            button.TextColor3 = Color3.new(1,1,1)
            button.BackgroundColor3 = color
            button.AutoButtonColor = true
            button.BorderSizePixel = 0

            local btnCorner = Instance.new("UICorner", button)
            btnCorner.CornerRadius = UDim.new(0, 8)

            return button
        end

        local yesBtn = createButton("Yes!", Color3.fromRGB(0, 200, 100))
        local noBtn = createButton("No :(", Color3.fromRGB(200, 50, 50))

        yesBtn.Parent = buttonHolder
        noBtn.Parent = buttonHolder

        -- Função para destruir com animação
        local function destroyAnimated(guiElement)
            TweenService:Create(guiElement, TweenInfo.new(0.3), {
                Size = UDim2.new(0, 0, 0, 0)
            }):Play()
            task.wait(0.35)
            guiElement:Destroy()
        end

        -- Clique em "Yes!"
        yesBtn.MouseButton1Click:Connect(function()
            if setclipboard then
                setclipboard("https://link-center.net/1182489/sakura-swoop-autofarm")
            end
            destroyAnimated(frame)

            -- Nova tela de agradecimento
            local thanks = Instance.new("TextLabel", screenGui)
            thanks.Size = UDim2.new(0, 0, 0, 0)
            thanks.Position = UDim2.new(0.5, -150, 0.4, 0)
            thanks.Text = "YAY! Link copied to clipboard :)"
            thanks.TextSize = 22
            thanks.Font = Enum.Font.GothamBold
            thanks.TextColor3 = Color3.fromRGB(255, 255, 255)
            thanks.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            thanks.BackgroundTransparency = 0.2
            thanks.BorderSizePixel = 0

            local corner2 = Instance.new("UICorner", thanks)
            corner2.CornerRadius = UDim.new(0, 10)

            TweenService:Create(thanks, TweenInfo.new(0.3), {
                Size = UDim2.new(0, 350, 0, 60)
            }):Play()

            task.wait(5)
            destroyAnimated(thanks)
            screenGui:Destroy()
        end)

        -- Clique em "No"
        noBtn.MouseButton1Click:Connect(function()
            destroyAnimated(frame)
        end)
    end
)

w1:Button(
    "Destroy GUI",
    function()
        for i, v in pairs(game.CoreGui:GetChildren()) do
            if v:FindFirstChild("Top") then
                v:Destroy()
            end
        end
    end
) -- Text, Callback
