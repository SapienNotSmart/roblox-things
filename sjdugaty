local TeleportService = game:GetService("TeleportService")

-- Hook na função Teleport para evitar que o jogo force um rejoin
local oldTeleport; oldTeleport = hookfunction(TeleportService.Teleport, function(...)
    warn("Blyadddd")
    return -- Cancela a execução da função
end)

-- Hook na função TeleportToPlaceInstance
local oldTeleportInstance; oldTeleportInstance = hookfunction(TeleportService.TeleportToPlaceInstance, function(...)
    warn("Kurwaaaa")
    return -- Cancela a execução da função
end)

print("Rejoin protection enabled")

local library = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))() -- aonde a library vai ficar armazenada

local w1 = library:Window("Cherry Blossom Festival") -- Text

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

local firstPosition = Vector3.new(-2968, 5502, 11817)
local secondPosition = Vector3.new(-3041, 5529, 11928)

local running = false
local platformParts = {}
local totalModelsPulled = 0
local maxModelsToCollect = 40
local collectionComplete = false

local function getJoinZonePath()
    if Workspace:FindFirstChild("Interiors") 
    and Workspace.Interiors:FindFirstChild("MainMap!Default") 
    and Workspace.Interiors["MainMap!Default"]:FindFirstChild("BlossomShakedownJoinZone") 
    and Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone:FindFirstChild("Collider") then
        return Workspace.Interiors["MainMap!Default"].BlossomShakedownJoinZone.Collider
    end
    return nil
end

local function teleportPlayer(pos)
    if typeof(pos) ~= "Vector3" then return false end
    
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            char.HumanoidRootPart.CFrame = CFrame.new(pos)
            for i = 1, 3 do
                task.wait(0.1)
                char.HumanoidRootPart.CFrame = CFrame.new(pos)
            end
        end)
        return true
    end
    return false
end

local function simulateJump()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        pcall(function()
            char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end)
        return true
    end
    return false
end

local function freezePlayer(position)
    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    if not hrp:FindFirstChild("FreezePosition") then
        pcall(function()
            local bp = Instance.new("BodyPosition")
            bp.Name = "FreezePosition"
            bp.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bp.P = 1e5
            bp.D = 1000
            bp.Position = position or hrp.Position
            bp.Parent = hrp
        end)
        return true
    end
    return false
end

local function unfreezePlayer()
    pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local bp = char.HumanoidRootPart:FindFirstChild("FreezePosition")
            if bp then bp:Destroy() end
        end
    end)
end

local function cleanupPlatform()
    pcall(function()
        for _, part in ipairs(platformParts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
    end)
    platformParts = {}
end

local function createSafePlatform(center)
    cleanupPlatform()
    
    if typeof(center) ~= "Vector3" then return end
    
    local platformSize = Vector3.new(30, 1, 30)
    local wallHeight = 20
    local wallThickness = 1

    local function makePart(size, pos)
        local success, part = pcall(function()
            local p = Instance.new("Part")
            p.Size = size
            p.Position = pos
            p.Anchored = true
            p.Material = Enum.Material.SmoothPlastic
            p.BrickColor = BrickColor.new("Medium stone grey")
            p.CanCollide = true
            p.Transparency = 0.5
            p.Parent = Workspace
            return p
        end)
        
        if success and part then
            table.insert(platformParts, part)
            return part
        end
        return nil
    end

    makePart(platformSize, center - Vector3.new(0, 0.5, 0))
    makePart(platformSize, center + Vector3.new(0, wallHeight, 0))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, -platformSize.Z/2))
    makePart(Vector3.new(platformSize.X, wallHeight, wallThickness), center + Vector3.new(0, wallHeight/2, platformSize.Z/2))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(-platformSize.X/2, wallHeight/2, 0))
    makePart(Vector3.new(wallThickness, wallHeight, platformSize.Z), center + Vector3.new(platformSize.X/2, wallHeight/2, 0))
end

local function isMinigameActive()
    local success, result = pcall(function()
        return Workspace:FindFirstChild("Interiors")
            and Workspace.Interiors:FindFirstChild("BlossomShakedownInterior")
            and Workspace.Interiors.BlossomShakedownInterior:FindFirstChild("RingPickups")
            and #Workspace.Interiors.BlossomShakedownInterior.RingPickups:GetChildren() > 0
    end)
    return success and result or false
end

local function getRingPickupsFolder()
    local success, result = pcall(function()
        return Workspace.Interiors.BlossomShakedownInterior.RingPickups
    end)
    return success and result or nil
end

local function pullModelsLoop()
    if collectionComplete then
        print("Coleta já concluída. Esperando o minigame terminar.")
        return
    end
    
    print("Iniciando coleta de models. Limite: " .. maxModelsToCollect)
    totalModelsPulled = 0
    
    while running and isMinigameActive() and totalModelsPulled < maxModelsToCollect do
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then 
            task.wait(0.5)
            continue 
        end

        local folder = getRingPickupsFolder()
        if not folder then
            task.wait(0.2)
            continue
        end

        if totalModelsPulled >= maxModelsToCollect then
            break
        end

        pcall(function()
            for _, model in ipairs(folder:GetChildren()) do
                if not running or totalModelsPulled >= maxModelsToCollect then 
                    break 
                end
                
                if model:IsA("Model") and model.Name == "Model" then
                    local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                    if part then
                        model:SetPrimaryPartCFrame(char.HumanoidRootPart.CFrame)
                        totalModelsPulled = totalModelsPulled + 1
                        print("Model trazido: " .. totalModelsPulled .. "/" .. maxModelsToCollect)
                        
                        task.wait(0.5)
                        
                        if totalModelsPulled >= maxModelsToCollect then
                            print("Limite de " .. maxModelsToCollect .. " models atingido. Parando.")
                            collectionComplete = true
                            break
                        end
                    end
                end
            end
        end)
        
        if totalModelsPulled >= maxModelsToCollect then
            collectionComplete = true
            break
        end
        
        task.wait(1)
    end
    
    collectionComplete = true
    print("Coleta de models finalizada. Total coletado: " .. totalModelsPulled)
end

-- Variável para rastrear quando o minigame terminou
local minigameJustEnded = false

local function startAutofarm()
    local wasInMinigame = false
    
    while running do
        local minigameActive = isMinigameActive()
        
        -- Detectar quando o minigame acabou de terminar
        if wasInMinigame and not minigameActive then
            minigameJustEnded = true
            print("Minigame acabou de terminar.")
        end
        wasInMinigame = minigameActive

        if not minigameActive then
            -- Se o minigame acabou de terminar, esperar 10 segundos
            if minigameJustEnded then
                print("Esperando período de estabilização após minigame...")
                unfreezePlayer()
                cleanupPlatform()
                
                -- Esperar 10 segundos antes de teleportar
                for i = 1, 10 do
                    if not running then break end
                    print("Aguardando: " .. i .. "/10 segundos")
                    task.wait(1)
                end
                
                minigameJustEnded = false
                print("Período de espera concluído, teleportando para zona de entrada")
            end
            
            -- Resetar variáveis quando não estiver no minigame
            totalModelsPulled = 0
            collectionComplete = false
            
            -- Teleportar para a zona de entrada do minigame
            local joinZone = getJoinZonePath()
            if joinZone then
                teleportPlayer(joinZone.Position + Vector3.new(0, 3, 0))
            end

            task.wait(2)
        else
            -- Só executa o setup e coleta se ainda não tiver coletado
            if not collectionComplete then
                -- Resetar contadores para o novo minigame
                totalModelsPulled = 0
                collectionComplete = false
                minigameJustEnded = false
                
                teleportPlayer(firstPosition)
                task.wait(1)

                teleportPlayer(secondPosition)
                createSafePlatform(secondPosition)
                task.wait(0.3)

                simulateJump()
                task.wait(0.3)

                freezePlayer()

                -- Executar a coleta uma única vez
                pullModelsLoop()
            end

            -- Verificar se o minigame ainda está ativo
            if isMinigameActive() then
                -- Continuar esperando na plataforma segura
                task.wait(3)
            else
                -- Não fazer nada aqui - deixar o loop detectar o fim do minigame
                -- na próxima iteração para acionar o delay
                task.wait(1)
            end
        end

        task.wait(1)
    end
end

-- 🔘 Toggle com biblioteca w1 (substitua pela sua UI se necessário)
w1:Toggle("Sakura Swoop Autofarm", "maf", false, function(toggled)
    running = toggled

    if toggled then
        -- Resetar variáveis ao ligar o script
        totalModelsPulled = 0
        collectionComplete = false
        minigameJustEnded = false
        
        pcall(function()
            task.spawn(startAutofarm)
        end)
    else
        unfreezePlayer()
        cleanupPlatform()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local root = char:WaitForChild("HumanoidRootPart")
-- Config
local joinZone = workspace.Interiors["MainMap!Default"].TearUpToykyoJoinZone.Collider
local safeReturnPos = Vector3.new(112, 41, -1365) -- posição segura após minigame

-- Void protection
local function isSafe(pos)
    local rayOrigin = pos + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return result ~= nil
end

local function teleportTo(pos, ignoreSafety)
    if ignoreSafety or isSafe(pos) then
        root.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
    end
end

local function isInMinigame()
    for _, interior in pairs(workspace.Interiors:GetChildren()) do
        if interior.Name:match("^KaijuStompMinigame::") then
            return true
        end
    end
    return false
end

local function teleportToTrees()
    while isInMinigame() and _G.kaijuAutofarm do
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Model") and v.Name == "Tree1" then
                local cf = v:GetModelCFrame()
                local targetPos = cf.Position
                if isSafe(targetPos) then
                    root.CFrame = cf + Vector3.new(0, 3, 0)
                    task.wait(0.25)
                end
            end
        end
        task.wait(0.5)
    end
end

w1:Toggle(
    "Tear Up Toykyo Autofarm",
    "frz",
    false,
    function(toggled)
        if toggled then
            _G.kaijuAutofarm = true
            
            -- Script principal de autofarm
            task.spawn(function()
                while _G.kaijuAutofarm do
                    if isInMinigame() then
                        teleportToTrees()
                        repeat task.wait() until not isInMinigame() or not _G.kaijuAutofarm
                        -- Proteção contra void: volta pra zona segura logo após o minigame
                        teleportTo(safeReturnPos, true) 
                        task.wait(2)
                    else
                        -- Sempre ficar na zona de entrada do minigame quando não estiver em um minigame
                        teleportTo(joinZone.Position)
                        task.wait(5)
                    end
                end
            end)
        else
            _G.kaijuAutofarm = false
        end
    end
)

w1:Button(
    "Anti-AFK",
    function()
local VirtualUser = game:GetService('VirtualUser')

game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AntiAFK loaded!",
    Text = "Enjoy!",
    Button1 = "OK",
    Duration = 5
})
end
)

w1:Label("YT: PabloScripts21") -- Text

w1:Button(
    "wanna support me?",
    function()
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")
        local player = Players.LocalPlayer
        local playerGui = player:FindFirstChild("PlayerGui")
        if not playerGui then return end

        -- Criar GUI principal
        local screenGui = Instance.new("ScreenGui", playerGui)
        screenGui.Name = "SupportPrompt"
        screenGui.ResetOnSpawn = false

        -- Frame principal
        local frame = Instance.new("Frame", screenGui)
        frame.Size = UDim2.new(0, 0, 0, 0) -- começa pequeno
        frame.Position = UDim2.new(0.5, -125, 0.4, 0)
        frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        frame.BackgroundTransparency = 0.2
        frame.BorderSizePixel = 0

        -- Arredondar bordas
        local corner = Instance.new("UICorner", frame)
        corner.CornerRadius = UDim.new(0, 12)

        -- Aparecer com animação
        TweenService:Create(frame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 300, 0, 160)
        }):Play()

        -- Título
        local title = Instance.new("TextLabel", frame)
        title.Size = UDim2.new(1, 0, 0.3, 0)
        title.Position = UDim2.new(0, 0, 0, 0)
        title.Text = "For real?"
        title.TextSize = 24
        title.Font = Enum.Font.GothamBold
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.BackgroundTransparency = 1

        -- Botões container
        local buttonHolder = Instance.new("Frame", frame)
        buttonHolder.Size = UDim2.new(1, 0, 0.5, 0)
        buttonHolder.Position = UDim2.new(0, 0, 0.5, 0)
        buttonHolder.BackgroundTransparency = 1

        local layout = Instance.new("UIListLayout", buttonHolder)
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 10)

        local function createButton(text, color)
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(0.45, 0, 1, 0)
            button.Text = text
            button.TextSize = 20
            button.Font = Enum.Font.GothamBold
            button.TextColor3 = Color3.new(1,1,1)
            button.BackgroundColor3 = color
            button.AutoButtonColor = true
            button.BorderSizePixel = 0

            local btnCorner = Instance.new("UICorner", button)
            btnCorner.CornerRadius = UDim.new(0, 8)

            return button
        end

        local yesBtn = createButton("Yes!", Color3.fromRGB(0, 200, 100))
        local noBtn = createButton("No :(", Color3.fromRGB(200, 50, 50))

        yesBtn.Parent = buttonHolder
        noBtn.Parent = buttonHolder

        -- Função para destruir com animação
        local function destroyAnimated(guiElement)
            TweenService:Create(guiElement, TweenInfo.new(0.3), {
                Size = UDim2.new(0, 0, 0, 0)
            }):Play()
            task.wait(0.35)
            guiElement:Destroy()
        end

        -- Clique em "Yes!"
        yesBtn.MouseButton1Click:Connect(function()
            if setclipboard then
                setclipboard("https://link-center.net/1182489/sakura-swoop-autofarm")
            end
            destroyAnimated(frame)

            -- Nova tela de agradecimento
            local thanks = Instance.new("TextLabel", screenGui)
            thanks.Size = UDim2.new(0, 0, 0, 0)
            thanks.Position = UDim2.new(0.5, -150, 0.4, 0)
            thanks.Text = "YAY! Link copied to clipboard :)"
            thanks.TextSize = 22
            thanks.Font = Enum.Font.GothamBold
            thanks.TextColor3 = Color3.fromRGB(255, 255, 255)
            thanks.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            thanks.BackgroundTransparency = 0.2
            thanks.BorderSizePixel = 0

            local corner2 = Instance.new("UICorner", thanks)
            corner2.CornerRadius = UDim.new(0, 10)

            TweenService:Create(thanks, TweenInfo.new(0.3), {
                Size = UDim2.new(0, 350, 0, 60)
            }):Play()

            task.wait(5)
            destroyAnimated(thanks)
            screenGui:Destroy()
        end)

        -- Clique em "No"
        noBtn.MouseButton1Click:Connect(function()
            destroyAnimated(frame)
        end)
    end
)

w1:Button(
    "Destroy GUI",
    function()
        for i, v in pairs(game.CoreGui:GetChildren()) do
            if v:FindFirstChild("Top") then
                v:Destroy()
            end
        end
    end
) -- Text, Callback
